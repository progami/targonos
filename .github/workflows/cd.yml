name: CD

on:
  push:
    branches:
      - dev
      - main
  workflow_dispatch:
    inputs:
      app:
        description: 'App to deploy (leave empty for auto-detect)'
        required: false
        type: choice
        options:
          - ''
          - sso
          - targon
          - talos
          - website
          - xplan
          - kairos
          - atlas
          - plutus
          - hermes
          - argus
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - main

permissions:
  contents: read

concurrency:
  group: cd-${{ github.workflow }}-${{ github.event_name == 'workflow_dispatch' && inputs.environment || github.ref_name }}
  cancel-in-progress: false

jobs:
  detect-changes:
    runs-on: [self-hosted, macOS, ARM64]
    outputs:
      sso: ${{ steps.changes.outputs.sso }}
      talos: ${{ steps.changes.outputs.talos }}
      website: ${{ steps.changes.outputs.website }}
      xplan: ${{ steps.changes.outputs.xplan }}
      kairos: ${{ steps.changes.outputs.kairos }}
      atlas: ${{ steps.changes.outputs.atlas }}
      plutus: ${{ steps.changes.outputs.plutus }}
      hermes: ${{ steps.changes.outputs.hermes }}
      argus: ${{ steps.changes.outputs.argus }}
      packages: ${{ steps.changes.outputs.packages }}
      any_app: ${{ steps.changes.outputs.any_app }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed apps
        id: changes
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ inputs.app }}" ]]; then
            echo "${{ inputs.app }}=true" >> "$GITHUB_OUTPUT"
            echo "any_app=true" >> "$GITHUB_OUTPUT"
          else
            if [[ "${{ github.event_name }}" == "push" ]]; then
              # For pushes, compare the entire range included in the event payload.
              BASE="${{ github.event.before }}"
              HEAD="${{ github.sha }}"

              if [[ -z "$BASE" || "$BASE" == "0000000000000000000000000000000000000000" ]]; then
                CHANGED_FILES="$(git ls-files)"
              else
                CHANGED_FILES="$(git diff --name-only "$BASE" "$HEAD")"
              fi
            else
              # For workflow_dispatch, fall back to "latest commit vs previous commit" on the selected branch.
              CHANGED_FILES="$(git diff --name-only HEAD^ HEAD 2>/dev/null || git diff --name-only HEAD)"
            fi

            echo "Changed files:"
            echo "$CHANGED_FILES"

            printf '%s\n' "$CHANGED_FILES" | node scripts/detect-cd-affected-apps.js >> "$GITHUB_OUTPUT"
          fi

  build-metadata:
    needs: detect-changes
    if: (github.event_name == 'push' && needs.detect-changes.outputs.any_app == 'true') || github.event_name == 'workflow_dispatch'
    runs-on: [self-hosted, macOS, ARM64]
    permissions:
      contents: write
    env:
      TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || github.ref_name }}
    outputs:
      version: ${{ steps.meta.outputs.version }}
      version_url: ${{ steps.meta.outputs.version_url }}
      commit_sha: ${{ steps.meta.outputs.commit_sha }}
      build_time: ${{ steps.meta.outputs.build_time }}
      tag: ${{ steps.meta.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || github.ref_name }}

      - name: Compute build metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail

          build_time="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          head_sha="$(git rev-parse HEAD)"
          commit_sha="$(git rev-parse --short=8 HEAD)"

          # NOTE:
          # - `git describe` picks the *nearest* tag by commit distance, not the highest semver tag.
          # - We want a monotonically increasing version on `main`, even when tags are not on the first-parent path.
          # Fetch tags from the remote directly so versioning stays correct even when tags are missing locally.
          # (GitHub Actions checkout can omit tags depending on fetch configuration and history shape.)
          remote_semver_tags="$(
            git ls-remote --tags origin | awk '
              {
                sha=$1
                ref=$2
                sub("^refs/tags/","",ref)
                peeled=0
                if (ref ~ /\^\{\}$/) { peeled=1; sub(/\^\{\}$/,"",ref) }
                tag=ref

                if (tag ~ /^v[0-9]+\.[0-9]+\.[0-9]+$/) {
                  if (peeled) { sha_by_tag[tag]=sha; peeled_by_tag[tag]=1 }
                  else if (!(tag in peeled_by_tag)) { sha_by_tag[tag]=sha }
                }
              }
              END { for (tag in sha_by_tag) print tag "\t" sha_by_tag[tag] }
            ' | tr -d '\r'
          )"

          is_release_run="false"
          if [[ "$TARGET_ENV" == "main" && "${GITHUB_EVENT_NAME}" == "push" ]]; then
            is_release_run="true"
          fi

          if [[ "$is_release_run" == "true" ]] && [[ -z "$remote_semver_tags" ]]; then
            echo "::error::No remote semver tags discovered; refusing to create a v0.0.x release."
            exit 1
          fi

          exact_tag="$(printf '%s\n' "$remote_semver_tags" | awk -v sha="$head_sha" '$2==sha {print $1}' | LC_ALL=C sort -V | tail -n 1 || true)"
          base_tag_line="$(printf '%s\n' "$remote_semver_tags" | LC_ALL=C sort -V -k1,1 | tail -n 1 || true)"
          base_tag=""
          base_sha=""
          if [[ -n "$base_tag_line" ]]; then
            base_tag="${base_tag_line%%$'\t'*}"
            base_sha="${base_tag_line#*$'\t'}"
          fi
          create_release="false"

          if [[ -n "$exact_tag" ]]; then
            version="${exact_tag#v}"
            tag="$exact_tag"
          else
            if [[ -n "$base_tag" ]]; then
              base_version="${base_tag#v}"
              if [[ -z "$base_sha" ]]; then
                echo "::warning::Could not resolve base_tag '$base_tag' to a commit SHA; using full history for bump detection"
                range="HEAD"
              elif git merge-base --is-ancestor "$base_sha" HEAD; then
                range="${base_sha}..HEAD"
              else
                merge_base="$(git merge-base "$base_sha" HEAD)"
                range="${merge_base}..HEAD"
              fi
            else
              range="HEAD"
              base_version="0.0.0"
            fi

            bump="patch"
            commit_messages="$(git log "$range" --pretty=%s%n%b)"

            if grep -qE 'BREAKING CHANGE|^[a-zA-Z]+(\(.+\))?!:' <<< "$commit_messages"; then
              bump="major"
            elif grep -qE '^feat(\(.+\))?:' <<< "$commit_messages"; then
              bump="minor"
            elif grep -qE '^fix(\(.+\))?:' <<< "$commit_messages"; then
              bump="patch"
            fi

            base_version="$(printf '%s' "$base_version" | tr -d '\r\n\t ')"
            if ! [[ "$base_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "::error::Expected base_version to be strict semver, got '$base_version' from base_tag '$base_tag'"
              exit 1
            fi

            IFS='.' read -r major minor patch <<< "$base_version"
            major="${major:-0}"
            minor="${minor:-0}"
            patch="${patch:-0}"

            case "$bump" in
              major)
                major=$((major + 1))
                minor=0
                patch=0
                ;;
              minor)
                minor=$((minor + 1))
                patch=0
                ;;
              patch)
                patch=$((patch + 1))
                ;;
            esac

            version="${major}.${minor}.${patch}"
            tag="v${version}"

            # Ensure we never reuse an existing tag (e.g., if older tags are off the mainline history).
            tag_exists() {
              git ls-remote --tags --refs origin "refs/tags/${1}" | grep -q .
            }

            while tag_exists "$tag"; do
              patch=$((patch + 1))
              version="${major}.${minor}.${patch}"
              tag="v${version}"
            done

            if [[ "$is_release_run" == "true" ]]; then
              create_release="true"
            fi
          fi

          use_release_url="false"
          if [[ "$TARGET_ENV" == "main" ]] && [[ -n "$exact_tag" || "$create_release" == "true" ]]; then
            use_release_url="true"
          fi

          if [[ "$use_release_url" == "true" ]]; then
            version_url="https://github.com/${GITHUB_REPOSITORY}/releases/tag/${tag}"
          else
            version_url="https://github.com/${GITHUB_REPOSITORY}/commit/${head_sha}"
          fi

          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "version_url=$version_url" >> "$GITHUB_OUTPUT"
          echo "commit_sha=$commit_sha" >> "$GITHUB_OUTPUT"
          echo "build_time=$build_time" >> "$GITHUB_OUTPUT"
          echo "create_release=$create_release" >> "$GITHUB_OUTPUT"

      - name: Create GitHub release (main only)
        if: github.event_name == 'push' && github.ref_name == 'main' && steps.meta.outputs.create_release == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.meta.outputs.tag }}
          name: Release ${{ steps.meta.outputs.tag }}
          # Repo default branch is `dev`, so explicitly tag the commit that triggered this workflow on `main`.
          target_commitish: ${{ github.sha }}
          generate_release_notes: true

  # ===========================================
  # DEPLOY - Only runs on push to dev/main
  # ===========================================
  deploy:
    needs: [detect-changes, build-metadata]
    if: github.event_name == 'push' && needs.detect-changes.outputs.any_app == 'true'
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
      - name: Setup pnpm
        shell: bash
        run: corepack enable && corepack prepare pnpm@10.21.0 --activate

      - name: Deploy changed apps
        shell: bash
        env:
          NEXT_PUBLIC_VERSION: ${{ needs.build-metadata.outputs.version }}
          NEXT_PUBLIC_RELEASE_URL: ${{ needs.build-metadata.outputs.version_url }}
          NEXT_PUBLIC_COMMIT_SHA: ${{ needs.build-metadata.outputs.commit_sha }}
          BUILD_TIME: ${{ needs.build-metadata.outputs.build_time }}
        run: |
          set -euo pipefail
          if command -v caffeinate >/dev/null 2>&1; then
            caffeinate -dimsu &
            caffeinate_pid="$!"
            trap 'kill "$caffeinate_pid" >/dev/null 2>&1 || true' EXIT
          fi

          TARGET_ENV="${{ github.ref_name }}"

          : "${TARGONOS_DEV_DIR:=${{ vars.TARGONOS_DEV_DIR }}}"
          : "${TARGONOS_MAIN_DIR:=${{ vars.TARGONOS_MAIN_DIR }}}"
          : "${TARGONOS_DEV_DIR:?Set TARGONOS_DEV_DIR on the self-hosted runner (or as a GitHub Actions repo variable)}"
          : "${TARGONOS_MAIN_DIR:?Set TARGONOS_MAIN_DIR on the self-hosted runner (or as a GitHub Actions repo variable)}"
          export TARGONOS_DEV_DIR TARGONOS_MAIN_DIR

          declare -a apps=()
          [[ "${{ needs.detect-changes.outputs.sso }}" == "true" ]] && apps+=(sso)
          [[ "${{ needs.detect-changes.outputs.talos }}" == "true" ]] && apps+=(talos)
          [[ "${{ needs.detect-changes.outputs.website }}" == "true" ]] && apps+=(website)
          [[ "${{ needs.detect-changes.outputs.xplan }}" == "true" ]] && apps+=(xplan)
          [[ "${{ needs.detect-changes.outputs.kairos }}" == "true" ]] && apps+=(kairos)
          [[ "${{ needs.detect-changes.outputs.atlas }}" == "true" ]] && apps+=(atlas)
          [[ "${{ needs.detect-changes.outputs.plutus }}" == "true" ]] && apps+=(plutus)
          [[ "${{ needs.detect-changes.outputs.hermes }}" == "true" ]] && apps+=(hermes)
          [[ "${{ needs.detect-changes.outputs.argus }}" == "true" ]] && apps+=(argus)

          if [[ ${#apps[@]} -eq 0 ]]; then
            echo "No deployable apps detected; exiting."
            exit 0
          fi

          BASE_SHA="${{ github.event.before }}"
          HEAD_SHA="${{ github.sha }}"

          # Default to a small fanout; fall back to sequential when needed.
          DEPLOY_CONCURRENCY="${DEPLOY_CONCURRENCY:-2}"

          first_app="${apps[0]}"

          # Prep once: update repo + install deps (or auto-skip install) before fanning out.
          DEPLOY_GIT_SHA="$HEAD_SHA" DEPLOY_BASE_SHA="$BASE_SHA" DEPLOY_HEAD_SHA="$HEAD_SHA" DEPLOY_SKIP_GIT=false DEPLOY_SKIP_INSTALL=false DEPLOY_SKIP_PM2_SAVE=true DEPLOY_PREP_ONLY=true \
            bash "${{ github.workspace }}/scripts/deploy-app.sh" "$first_app" "$TARGET_ENV"

          # Use the deployed repo clone (full history) for safety checks.
          if [[ "$TARGET_ENV" == "dev" ]]; then
            DEPLOY_REPO_DIR="${TARGONOS_DEV_DIR}"
          else
            DEPLOY_REPO_DIR="${TARGONOS_MAIN_DIR}"
          fi

          if [[ -z "$BASE_SHA" || "$BASE_SHA" == "0000000000000000000000000000000000000000" ]]; then
            CHANGED_FILES="$(cd "$DEPLOY_REPO_DIR" && git ls-files)"
          else
            CHANGED_FILES="$(cd "$DEPLOY_REPO_DIR" && git diff --name-only "$BASE_SHA" "$HEAD_SHA" || true)"
          fi

          unsafe_parallel="false"
          if grep -qx 'apps/talos/prisma/schema.prisma' <<< "$CHANGED_FILES" && ! grep -q '^packages/prisma-talos/generated/' <<< "$CHANGED_FILES"; then
            unsafe_parallel="true"
          fi
          if grep -qx 'apps/xplan/prisma/schema.prisma' <<< "$CHANGED_FILES" && ! grep -q '^packages/prisma-xplan/generated/' <<< "$CHANGED_FILES"; then
            unsafe_parallel="true"
          fi
          if grep -qx 'apps/kairos/prisma/schema.prisma' <<< "$CHANGED_FILES" && ! grep -q '^packages/prisma-kairos/generated/' <<< "$CHANGED_FILES"; then
            unsafe_parallel="true"
          fi
          if grep -qx 'apps/atlas/prisma/schema.prisma' <<< "$CHANGED_FILES" && ! grep -q '^packages/prisma-atlas/generated/' <<< "$CHANGED_FILES"; then
            unsafe_parallel="true"
          fi
          if grep -qx 'apps/argus/prisma/schema.prisma' <<< "$CHANGED_FILES" && ! grep -q '^packages/prisma-argus/generated/' <<< "$CHANGED_FILES"; then
            unsafe_parallel="true"
          fi

          if [[ ${#apps[@]} -le 1 || "$unsafe_parallel" == "true" ]]; then
            DEPLOY_CONCURRENCY="1"
          fi

          echo "Deploying to $TARGET_ENV: ${apps[*]} (concurrency=$DEPLOY_CONCURRENCY)"

          export DEPLOY_BASE_SHA="$BASE_SHA"
          export DEPLOY_HEAD_SHA="$HEAD_SHA"
          export DEPLOY_SKIP_GIT=true
          export DEPLOY_SKIP_INSTALL=true
          export DEPLOY_SKIP_PM2_SAVE=true

          printf '%s\n' "${apps[@]}" | xargs -n 1 -P "$DEPLOY_CONCURRENCY" -I {} bash "${{ github.workspace }}/scripts/deploy-app.sh" {} "$TARGET_ENV"

          echo "Saving PM2 state once"
          pm2 save

  # ===========================================
  # MANUAL DEPLOY - For workflow_dispatch
  # ===========================================
  manual-deploy:
    needs: [detect-changes, build-metadata]
    if: github.event_name == 'workflow_dispatch'
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
      - name: Setup pnpm
        shell: bash
        run: corepack enable && corepack prepare pnpm@10.21.0 --activate

      - name: Deploy selected app(s)
        shell: bash
        env:
          NEXT_PUBLIC_VERSION: ${{ needs.build-metadata.outputs.version }}
          NEXT_PUBLIC_RELEASE_URL: ${{ needs.build-metadata.outputs.version_url }}
          NEXT_PUBLIC_COMMIT_SHA: ${{ needs.build-metadata.outputs.commit_sha }}
          BUILD_TIME: ${{ needs.build-metadata.outputs.build_time }}
        run: |
          set -euo pipefail
          if command -v caffeinate >/dev/null 2>&1; then
            caffeinate -dimsu &
            caffeinate_pid="$!"
            trap 'kill "$caffeinate_pid" >/dev/null 2>&1 || true' EXIT
          fi

          requested_app="${{ inputs.app }}"
          target_env="${{ inputs.environment }}"

          : "${TARGONOS_DEV_DIR:=${{ vars.TARGONOS_DEV_DIR }}}"
          : "${TARGONOS_MAIN_DIR:=${{ vars.TARGONOS_MAIN_DIR }}}"
          : "${TARGONOS_DEV_DIR:?Set TARGONOS_DEV_DIR on the self-hosted runner (or as a GitHub Actions repo variable)}"
          : "${TARGONOS_MAIN_DIR:?Set TARGONOS_MAIN_DIR on the self-hosted runner (or as a GitHub Actions repo variable)}"
          export TARGONOS_DEV_DIR TARGONOS_MAIN_DIR

          # Backwards compatibility: older workflows used "targon" for the portal key.
          if [[ "$requested_app" == "targon" ]]; then
            requested_app="sso"
          fi

          declare -a apps=()
          if [[ -n "$requested_app" ]]; then
            apps=("$requested_app")
          else
            [[ "${{ needs.detect-changes.outputs.sso }}" == "true" ]] && apps+=(sso)
            [[ "${{ needs.detect-changes.outputs.talos }}" == "true" ]] && apps+=(talos)
            [[ "${{ needs.detect-changes.outputs.website }}" == "true" ]] && apps+=(website)
            [[ "${{ needs.detect-changes.outputs.xplan }}" == "true" ]] && apps+=(xplan)
            [[ "${{ needs.detect-changes.outputs.kairos }}" == "true" ]] && apps+=(kairos)
            [[ "${{ needs.detect-changes.outputs.atlas }}" == "true" ]] && apps+=(atlas)
            [[ "${{ needs.detect-changes.outputs.plutus }}" == "true" ]] && apps+=(plutus)
            [[ "${{ needs.detect-changes.outputs.hermes }}" == "true" ]] && apps+=(hermes)
            [[ "${{ needs.detect-changes.outputs.argus }}" == "true" ]] && apps+=(argus)
          fi

          if [[ ${#apps[@]} -eq 0 ]]; then
            echo "No deployable apps detected; exiting."
            exit 0
          fi

          echo "Manual deploy to $target_env: ${apps[*]}"

          DEPLOY_CONCURRENCY="${DEPLOY_CONCURRENCY:-2}"
          if [[ ${#apps[@]} -le 1 ]]; then
            DEPLOY_CONCURRENCY="1"
          fi

          first_app="${apps[0]}"

          # Prep once: update repo + install deps (or auto-skip install) before fanning out.
          DEPLOY_SKIP_GIT=false DEPLOY_SKIP_INSTALL=false DEPLOY_SKIP_PM2_SAVE=true DEPLOY_PREP_ONLY=true \
            bash "${{ github.workspace }}/scripts/deploy-app.sh" "$first_app" "$target_env"

          export DEPLOY_SKIP_GIT=true
          export DEPLOY_SKIP_INSTALL=true
          export DEPLOY_SKIP_PM2_SAVE=true

          printf '%s\n' "${apps[@]}" | xargs -n 1 -P "$DEPLOY_CONCURRENCY" -I {} bash "${{ github.workspace }}/scripts/deploy-app.sh" {} "$target_env"

          echo "Saving PM2 state once"
          pm2 save
